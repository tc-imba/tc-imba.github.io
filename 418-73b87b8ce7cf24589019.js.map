{"version":3,"file":"418-73b87b8ce7cf24589019.js","mappings":"6GAAA,IAAIA,EAAO,EAAQ,MAsBnBC,EAAOC,QAJG,WACR,OAAOF,EAAKG,KAAKC,KACnB,C,6KCTO,SAASC,EAAiBC,EAAaC,GAC5C,IAAIC,GAAiB,IAAAC,WACrB,IAAAC,YAAU,WACR,IAAKF,EAAeG,QAAS,CAC3B,IAAIC,EAAgC,mBAAhBN,EAA6BA,IAAgBA,EAC7DM,IACFJ,EAAeG,QAAU,IAAI,KAAeJ,GAC5CC,EAAeG,QAAQE,QAAQD,GAEnC,CACA,OAAO,WACL,IAAIE,EACiD,QAApDA,EAAwBN,EAAeG,eAA+C,IAA1BG,GAAoCA,EAAsBC,YACzH,CACF,GAAG,CAACT,EAAaC,GACnB,CACA,I,oBCfO,SAASS,EAAiBV,EAAaW,EAAOV,EAAUW,QAC7C,IAAZA,IACFA,GAAU,IAEZ,IAAAR,YAAU,WACR,IAAIE,EAAgC,mBAAhBN,EAA6BA,IAAgBA,EAC7Da,EAAaP,GAAS,EAAAQ,EAAA,GAAGR,EAAQK,EAAOV,EAAUW,GAAW,KACjE,OAAO,WACLC,SAAgDA,EAAWE,KAC7D,CACF,GAAG,CAACf,EAAaW,EAAOV,EAAUW,GACpC,CACA,I,4BCrBII,EAAY,CAAC,KAAM,cAAe,YAAa,WAAY,YAAa,MAAO,WAAY,kBAsG/F,IAAIC,EAAqB,cAAiB,SAAUC,EAAOC,GACzD,IAAIC,EAEFC,GADe,EAAAC,EAAA,GAAU,QAASJ,GACHG,kBAC7BE,EAAwBF,EAAkBG,GAC5CC,OAAsC,IAA1BF,EAAmC,MAAQA,EACvDG,EAAwBL,EAAkBM,YAC1CA,OAAwC,IAA1BD,EAAmC,QAAUA,EAC3DE,EAAYP,EAAkBO,UAC9BC,EAAWR,EAAkBQ,SAC7BC,EAAYT,EAAkBS,UAC9BC,EAAwBV,EAAkBW,IAC1CA,OAAgC,IAA1BD,EAAmC,EAAIA,EAC7CE,EAAWZ,EAAkBY,SAC7BC,EAAiBb,EAAkBa,eACnCC,GAAO,OAA8Bd,EAAmBL,GACtDoB,GAAW,IAAAjC,QAAO,MAClBkC,EA5GN,SAAmBD,EAAUF,GAC3B,IAAII,GAAY,IAAAC,UAAS,MACvBF,EAASC,EAAU,GACnBE,EAAYF,EAAU,GACpBG,GAAe,IAAAC,cAAY,WAC7B,GAAKN,EAAS/B,QAAd,CAGA,IAAIsC,GAAY,EAAAC,EAAA,GAAUR,EAAS/B,UAC9BsC,aAA6C,EAASA,EAAUE,WAAaR,aAAuC,EAASA,EAAOQ,UAAYF,aAA6C,EAASA,EAAUG,UAAYT,aAAuC,EAASA,EAAOS,SAAWH,aAA6C,EAASA,EAAUX,QAAUK,aAAuC,EAASA,EAAOL,OAASW,aAA6C,EAASA,EAAUI,SAAWV,aAAuC,EAASA,EAAOU,QAC7iBP,EAAUG,GACK,OAAXN,GAAiC,OAAdM,IACrBT,SAAwDA,EAAeS,IAL3E,CAQF,GAAG,CAACP,EAAUC,EAAQH,IAetB,OAZAnC,GAAiB,WACf,OAAOqC,EAAS/B,OAClB,GAAGoC,IAGH,EAAAO,EAAA,GAASP,GAGT/B,EAAiBuC,OAAQ,SAAUR,GAAc,GAGjD/B,EAAiBuC,OAAQ,SAAU,IAASR,EAAc,MAAM,GACzDJ,CACT,CA6Eea,CAAUd,EAAUF,GAC7BiB,EAxEN,SAA4BrB,GAC1B,IAAIsB,GAAa,IAAAb,UAAS,MACxBF,EAASe,EAAW,GACpBZ,EAAYY,EAAW,GAKzB,OAJA,IAAAhD,YAAU,WACR,IAAIiD,EAA4B,mBAAdvB,EAA2BA,IAAcA,EAC3DU,EAAUa,GAAO,EAAAT,EAAA,GAAUS,GAAQ,KACrC,GAAG,CAACvB,IACGO,CACT,CA+DwBiB,CAAmBxB,GACrCyB,EAxDN,SAAkBlB,EAAQc,EAAiBjC,GACzC,IAAIc,EAAMd,EAAMc,IACdC,EAAWf,EAAMe,SACfuB,GAAa,IAAAjB,WAAS,GACxBgB,EAAQC,EAAW,GACnBC,EAAWD,EAAW,GACpBE,GAAe,IAAAhB,cAAY,WAC7B,GAAKL,EAAL,CAGA,IAAIsB,EAAUV,OAAOU,SAAWV,OAAOW,YAGnCC,EAAYF,GAAWG,OAAOzB,aAAuC,EAASA,EAAOL,KAAO8B,OAAO9B,KAAS,EAI5GmB,IACFU,EAAYA,GAAaF,EAAUG,OAAOX,EAAgBnB,KAAO8B,OAAOX,EAAgBN,SAEtFgB,IAAcN,IAChBE,EAASI,GACT5B,SAA4CA,EAAS4B,GAbvD,CAeF,GAAG,CAACxB,EAAQL,EAAKmB,EAAiBI,EAAOtB,IAIzC,OADAvB,EAAiBuC,OAAQ,SAAUS,GAAc,GAC1CH,CACT,CA2BcQ,CAAS1B,EAAQc,EAAiB,CAC5CnB,IAAKA,EACLC,SAAUA,IAER+B,GAAiB,EAAAC,EAAA,GAActC,GACjCuC,EAAkBF,EAAeE,gBAE/BC,GAAUC,EADJJ,EAAeI,OACLxC,IAAYR,EAAS,CAAC,GAAU8C,KAAqBX,EAAOnC,IAC5EiD,EAAOhC,GAAU,CAAC,EACpBS,EAAQuB,EAAKvB,MACbD,EAASwB,EAAKxB,OACZyB,EAAoBf,EAAQ,CAC9BT,MAAOA,EACPD,OAAQA,QACN0B,EAOAC,EAAcjB,EANA,CAChBkB,SAAU,QACVzC,IAAKA,EACLc,MAAOA,EACP4B,OAAQ,SAE8BH,EACxC,OAAoB,gBAAoB9C,GAAW,OAAS,CAAC,EAAGU,EAAM,CACpEhB,KAAK,EAAAwD,EAAA,GAAUvC,EAAUjB,KACV,gBAAoB,MAAO,CAC1CS,UAAWuC,EACXS,MAAOJ,GACN3C,GAAW0B,GAAsB,gBAAoB,MAAO,CAC7D,eAAe,EACfqB,MAAON,IAEX,IACArD,EAAM4D,YAAc,QACpB5D,EAAM6D,UAAY,CAChB9C,IAAK,WACLC,SAAU,SACVH,UAAW,cAAoB,CAAC,QAAe,YAEjD,IChKA,EDgKA,C,kFEhKWkB,EAAW,SAAkB+B,GACtC,IAAI3C,GAAW,IAAAjC,QAAO4E,GACtB3C,EAAS/B,QAAU0E,GACnB,IAAA3E,YAAU,WACR,IAAI4E,EACuC,QAA1CA,EAAoB5C,EAAS/B,eAA2C,IAAtB2E,GAAgCA,EAAkBC,KAAK7C,EAC5G,GAAG,GACL,C,uBCTA,IAAI8C,EAAW,EAAQ,MACnBpF,EAAM,EAAQ,KACdqF,EAAW,EAAQ,MAMnBC,EAAYC,KAAKC,IACjBC,EAAYF,KAAKG,IAqLrB7F,EAAOC,QA7HP,SAAkB6F,EAAMC,EAAMC,GAC5B,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAAiB,EACjBC,GAAU,EACVC,GAAS,EACTC,GAAW,EAEf,GAAmB,mBAARZ,EACT,MAAM,IAAIa,UAzEQ,uBAmFpB,SAASC,EAAWC,GAClB,IAAIC,EAAOb,EACPc,EAAUb,EAKd,OAHAD,EAAWC,OAAWtB,EACtB2B,EAAiBM,EACjBT,EAASN,EAAKkB,MAAMD,EAASD,EAE/B,CAqBA,SAASG,EAAaJ,GACpB,IAAIK,EAAoBL,EAAOP,EAM/B,YAAyB1B,IAAjB0B,GAA+BY,GAAqBnB,GACzDmB,EAAoB,GAAOT,GANJI,EAAON,GAM8BJ,CACjE,CAEA,SAASgB,IACP,IAAIN,EAAO1G,IACX,GAAI8G,EAAaJ,GACf,OAAOO,EAAaP,GAGtBR,EAAUgB,WAAWF,EA3BvB,SAAuBN,GACrB,IAEIS,EAAcvB,GAFMc,EAAOP,GAI/B,OAAOG,EACHb,EAAU0B,EAAanB,GAJDU,EAAON,IAK7Be,CACN,CAmBqCC,CAAcV,GACnD,CAEA,SAASO,EAAaP,GAKpB,OAJAR,OAAUzB,EAIN8B,GAAYT,EACPW,EAAWC,IAEpBZ,EAAWC,OAAWtB,EACfwB,EACT,CAcA,SAASoB,IACP,IAAIX,EAAO1G,IACPsH,EAAaR,EAAaJ,GAM9B,GAJAZ,EAAWyB,UACXxB,EAAWyB,KACXrB,EAAeO,EAEXY,EAAY,CACd,QAAgB7C,IAAZyB,EACF,OAzEN,SAAqBQ,GAMnB,OAJAN,EAAiBM,EAEjBR,EAAUgB,WAAWF,EAAcpB,GAE5BS,EAAUI,EAAWC,GAAQT,CACtC,CAkEawB,CAAYtB,GAErB,GAAIG,EAIF,OAFAoB,aAAaxB,GACbA,EAAUgB,WAAWF,EAAcpB,GAC5Ba,EAAWN,EAEtB,CAIA,YAHgB1B,IAAZyB,IACFA,EAAUgB,WAAWF,EAAcpB,IAE9BK,CACT,CAGA,OA3GAL,EAAOP,EAASO,IAAS,EACrBR,EAASS,KACXQ,IAAYR,EAAQQ,QAEpBL,GADAM,EAAS,YAAaT,GACHP,EAAUD,EAASQ,EAAQG,UAAY,EAAGJ,GAAQI,EACrEO,EAAW,aAAcV,IAAYA,EAAQU,SAAWA,GAoG1Dc,EAAUM,OApCV,gBACkBlD,IAAZyB,GACFwB,aAAaxB,GAEfE,EAAiB,EACjBN,EAAWK,EAAeJ,EAAWG,OAAUzB,CACjD,EA+BA4C,EAAUO,MA7BV,WACE,YAAmBnD,IAAZyB,EAAwBD,EAASgB,EAAajH,IACvD,EA4BOqH,CACT,C","sources":["webpack://tc-imba.github.io/./node_modules/lodash/now.js","webpack://tc-imba.github.io/./node_modules/rsuite/esm/internals/hooks/useElementResize.js","webpack://tc-imba.github.io/./node_modules/rsuite/esm/internals/hooks/useEventListener.js","webpack://tc-imba.github.io/./node_modules/rsuite/esm/Affix/Affix.js","webpack://tc-imba.github.io/./node_modules/rsuite/esm/Affix/index.js","webpack://tc-imba.github.io/./node_modules/rsuite/esm/internals/hooks/useMount.js","webpack://tc-imba.github.io/./node_modules/lodash/debounce.js"],"sourcesContent":["var root = require('./_root');\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n","'use client';\nimport { useEffect, useRef } from 'react';\nimport { ResizeObserver } from '@juggle/resize-observer';\n\n/**\n * Attach the event handler directly to the specified DOM element,\n * and it will be triggered when the size of the DOM element is changed.\n *\n * @param eventTarget The target to listen for events on\n * @param listener An event handler\n */\nexport function useElementResize(eventTarget, listener) {\n  var resizeObserver = useRef();\n  useEffect(function () {\n    if (!resizeObserver.current) {\n      var target = typeof eventTarget === 'function' ? eventTarget() : eventTarget;\n      if (target) {\n        resizeObserver.current = new ResizeObserver(listener);\n        resizeObserver.current.observe(target);\n      }\n    }\n    return function () {\n      var _resizeObserver$curre;\n      (_resizeObserver$curre = resizeObserver.current) === null || _resizeObserver$curre === void 0 || _resizeObserver$curre.disconnect();\n    };\n  }, [eventTarget, listener]);\n}\nexport default useElementResize;","'use client';\nimport { useEffect } from 'react';\nimport on from 'dom-lib/on';\n\n/**\n * Attach the event handler directly to the specified DOM element.\n *\n * @param element The target to listen for events on\n * @param event The DOM event name\n * @param handler An event handler\n * @param capture Whether or not to listen during the capture event phase\n */\nexport function useEventListener(eventTarget, event, listener, capture) {\n  if (capture === void 0) {\n    capture = false;\n  }\n  useEffect(function () {\n    var target = typeof eventTarget === 'function' ? eventTarget() : eventTarget;\n    var controller = target ? on(target, event, listener, capture) : null;\n    return function () {\n      controller === null || controller === void 0 || controller.off();\n    };\n  }, [eventTarget, event, listener, capture]);\n}\nexport default useEventListener;","'use client';\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nvar _excluded = [\"as\", \"classPrefix\", \"className\", \"children\", \"container\", \"top\", \"onChange\", \"onOffsetChange\"];\nimport React, { useCallback, useEffect, useRef, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport debounce from 'lodash/debounce';\nimport getOffset from 'dom-lib/getOffset';\nimport { useClassNames, useElementResize, useEventListener, useMount } from \"../internals/hooks/index.js\";\nimport { mergeRefs } from \"../internals/utils/index.js\";\nimport { useCustom } from \"../CustomProvider/index.js\";\n/**\n * Get the layout size and offset of the mount element\n */\nfunction useOffset(mountRef, onOffsetChange) {\n  var _useState = useState(null),\n    offset = _useState[0],\n    setOffset = _useState[1];\n  var updateOffset = useCallback(function () {\n    if (!mountRef.current) {\n      return;\n    }\n    var newOffset = getOffset(mountRef.current);\n    if ((newOffset === null || newOffset === void 0 ? void 0 : newOffset.height) !== (offset === null || offset === void 0 ? void 0 : offset.height) || (newOffset === null || newOffset === void 0 ? void 0 : newOffset.width) !== (offset === null || offset === void 0 ? void 0 : offset.width) || (newOffset === null || newOffset === void 0 ? void 0 : newOffset.top) !== (offset === null || offset === void 0 ? void 0 : offset.top) || (newOffset === null || newOffset === void 0 ? void 0 : newOffset.left) !== (offset === null || offset === void 0 ? void 0 : offset.left)) {\n      setOffset(newOffset);\n      if (offset !== null && newOffset !== null) {\n        onOffsetChange === null || onOffsetChange === void 0 || onOffsetChange(newOffset);\n      }\n    }\n  }, [mountRef, offset, onOffsetChange]);\n\n  // Update after the element size changes\n  useElementResize(function () {\n    return mountRef.current;\n  }, updateOffset);\n\n  // Initialize after the first render\n  useMount(updateOffset);\n\n  // Update after window size changes\n  useEventListener(window, 'resize', updateOffset, false);\n\n  // Update after window scroll\n  useEventListener(window, 'scroll', debounce(updateOffset, 100), false);\n  return offset;\n}\n\n/**\n * Get the layout size and offset of the container element\n * @param container\n */\nfunction useContainerOffset(container) {\n  var _useState2 = useState(null),\n    offset = _useState2[0],\n    setOffset = _useState2[1];\n  useEffect(function () {\n    var node = typeof container === 'function' ? container() : container;\n    setOffset(node ? getOffset(node) : null);\n  }, [container]);\n  return offset;\n}\n\n/**\n * Check whether the current element should be in a fixed state.\n * @param offset\n * @param containerOffset\n * @param props\n */\nfunction useFixed(offset, containerOffset, props) {\n  var top = props.top,\n    onChange = props.onChange;\n  var _useState3 = useState(false),\n    fixed = _useState3[0],\n    setFixed = _useState3[1];\n  var handleScroll = useCallback(function () {\n    if (!offset) {\n      return;\n    }\n    var scrollY = window.scrollY || window.pageYOffset;\n\n    // When the scroll distance exceeds the element's top value, it is fixed.\n    var nextFixed = scrollY - (Number(offset === null || offset === void 0 ? void 0 : offset.top) - Number(top)) >= 0;\n\n    // If the current element is specified in the container,\n    // add to determine whether the current container is in the window range.\n    if (containerOffset) {\n      nextFixed = nextFixed && scrollY < Number(containerOffset.top) + Number(containerOffset.height);\n    }\n    if (nextFixed !== fixed) {\n      setFixed(nextFixed);\n      onChange === null || onChange === void 0 || onChange(nextFixed);\n    }\n  }, [offset, top, containerOffset, fixed, onChange]);\n\n  // Add scroll event to window\n  useEventListener(window, 'scroll', handleScroll, false);\n  return fixed;\n}\n\n/**\n * Components such as navigation, buttons, etc. can be fixed in the visible range.\n * Commonly used for pages with long content, fixed the specified elements in the visible range of the page to assist in quick operation.\n *\n * @see https://rsuitejs.com/components/affix/\n */\nvar Affix = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  var _merge;\n  var _useCustom = useCustom('Affix', props),\n    propsWithDefaults = _useCustom.propsWithDefaults;\n  var _propsWithDefaults$as = propsWithDefaults.as,\n    Component = _propsWithDefaults$as === void 0 ? 'div' : _propsWithDefaults$as,\n    _propsWithDefaults$cl = propsWithDefaults.classPrefix,\n    classPrefix = _propsWithDefaults$cl === void 0 ? 'affix' : _propsWithDefaults$cl,\n    className = propsWithDefaults.className,\n    children = propsWithDefaults.children,\n    container = propsWithDefaults.container,\n    _propsWithDefaults$to = propsWithDefaults.top,\n    top = _propsWithDefaults$to === void 0 ? 0 : _propsWithDefaults$to,\n    onChange = propsWithDefaults.onChange,\n    onOffsetChange = propsWithDefaults.onOffsetChange,\n    rest = _objectWithoutPropertiesLoose(propsWithDefaults, _excluded);\n  var mountRef = useRef(null);\n  var offset = useOffset(mountRef, onOffsetChange);\n  var containerOffset = useContainerOffset(container);\n  var fixed = useFixed(offset, containerOffset, {\n    top: top,\n    onChange: onChange\n  });\n  var _useClassNames = useClassNames(classPrefix),\n    withClassPrefix = _useClassNames.withClassPrefix,\n    merge = _useClassNames.merge;\n  var classes = merge(className, (_merge = {}, _merge[withClassPrefix()] = fixed, _merge));\n  var _ref = offset || {},\n    width = _ref.width,\n    height = _ref.height;\n  var placeholderStyles = fixed ? {\n    width: width,\n    height: height\n  } : undefined;\n  var fixedStyles = {\n    position: 'fixed',\n    top: top,\n    width: width,\n    zIndex: 10\n  };\n  var affixStyles = fixed ? fixedStyles : undefined;\n  return /*#__PURE__*/React.createElement(Component, _extends({}, rest, {\n    ref: mergeRefs(mountRef, ref)\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    className: classes,\n    style: affixStyles\n  }, children), fixed && /*#__PURE__*/React.createElement(\"div\", {\n    \"aria-hidden\": true,\n    style: placeholderStyles\n  }));\n});\nAffix.displayName = 'Affix';\nAffix.propTypes = {\n  top: PropTypes.number,\n  onChange: PropTypes.func,\n  container: PropTypes.oneOfType([PropTypes.any, PropTypes.func])\n};\nexport default Affix;","'use client';\nimport Affix from \"./Affix.js\";\nexport default Affix;","'use client';\nimport { useEffect, useRef } from 'react';\nexport var useMount = function useMount(callback) {\n  var mountRef = useRef(callback);\n  mountRef.current = callback;\n  useEffect(function () {\n    var _mountRef$current;\n    (_mountRef$current = mountRef.current) === null || _mountRef$current === void 0 || _mountRef$current.call(mountRef);\n  }, []);\n};\nexport default useMount;","var isObject = require('./isObject'),\n    now = require('./now'),\n    toNumber = require('./toNumber');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n"],"names":["root","module","exports","Date","now","useElementResize","eventTarget","listener","resizeObserver","useRef","useEffect","current","target","observe","_resizeObserver$curre","disconnect","useEventListener","event","capture","controller","on","off","_excluded","Affix","props","ref","_merge","propsWithDefaults","useCustom","_propsWithDefaults$as","as","Component","_propsWithDefaults$cl","classPrefix","className","children","container","_propsWithDefaults$to","top","onChange","onOffsetChange","rest","mountRef","offset","_useState","useState","setOffset","updateOffset","useCallback","newOffset","getOffset","height","width","left","useMount","window","useOffset","containerOffset","_useState2","node","useContainerOffset","fixed","_useState3","setFixed","handleScroll","scrollY","pageYOffset","nextFixed","Number","useFixed","_useClassNames","useClassNames","withClassPrefix","classes","merge","_ref","placeholderStyles","undefined","affixStyles","position","zIndex","mergeRefs","style","displayName","propTypes","callback","_mountRef$current","call","isObject","toNumber","nativeMax","Math","max","nativeMin","min","func","wait","options","lastArgs","lastThis","maxWait","result","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","TypeError","invokeFunc","time","args","thisArg","apply","shouldInvoke","timeSinceLastCall","timerExpired","trailingEdge","setTimeout","timeWaiting","remainingWait","debounced","isInvoking","arguments","this","leadingEdge","clearTimeout","cancel","flush"],"sourceRoot":""}