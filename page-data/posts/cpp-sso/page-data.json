{"componentChunkName":"component---node-modules-gatsby-theme-academic-src-templates-post-post-jsx-content-file-path-content-posts-2020-10-04-cpp-sso-index-md","path":"/posts/cpp-sso/","result":{"data":{"mdx":{"tableOfContents":{"items":[{"url":"#implementation-of-stdstring","title":"Implementation of std::string","items":[{"url":"#g","title":"g++"},{"url":"#llvmclang","title":"llvm/clang"}]}]},"frontmatter":{"cover":null},"fields":{"slug":{"html":"\n## Implementation of `std::string`\n\n### `g++`\n\nIn `g++` (libstdc++) implementation, Assuming a 64-bit OS, the class structure (with the size of each attribute) can be simplified as:\n\n```cpp\ntemplate<typename value_type>\nclass basic_string {\n    enum { __min_cap = 15 / sizeof(value_type) };\n\n    pointer   __data_;                     //  8 bytes\n    size_type __size_;                     //  8 bytes\n\n    union {\n        value_type __data_[__min_cap + 1]; // 16 bytes\n        size_type  __cap_;                 //  8 bytes\n    } __u_;                                // 16 bytes\n};                                         // 32 bytes\n```\n\nThe capacity (`size_type`, 8 bytes) is combined with a char array in a union if the string length is less than local capacity.\n\nThe template argument `value_type` is define to support both `char` and `wchar_t`.\n\n+ `basic_string<char>` has a local capacity of 15.\n+ `basic_string<wchar_t>` has a local capacity of 7.\n+ we need one more char to store `\\0`.\n\n<br />\n\nBoth of them have a total size of 32 bytes. The size of the char array is 16 bytes, because in `g++`, a minimum block allocated by dynamic memory allocation (malloc/new) is 16 bytes (so less than 16 bytes is not a good optimization).\n\nYou may notice that there exists an overhead of 8 bytes in the union. This is ignorable if you do not need to store huge amounts of small strings in memory.\n\n### `llvm/clang`\n\nIn `llvm/clang` (libc++) implementation, the overhead can be cancelled by a smarter design: using the entire structure to store the small string.\n\nWe define two modes for each string: long string mode and short string mode, each in a separate struct, and then combine them together with a union.\n\n```cpp\ntemplate<typename value_type>\nclass basic_string {\n    struct __long {\n        size_type __cap_;               // 8      bytes\n        size_type __size_;              // 8      bytes\n        pointer   __data_;              // 8      bytes\n    };\n\n    enum {__min_cap = (sizeof(__long) - 1) / sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1) / sizeof(value_type) : 2};\n\n    struct __short {\n        union {\n            unsigned char __size_;      // 1      byte\n            value_type __lx;            // 1 (2)  bytes for char(wchar_t)\n        };                              // 1 (2)  bytes for char(wchar_t)\n        value_type __data_[__min_cap];  // 23(22) bytes for char(wchar_t)\n    };                                  // 24     bytes\n\n    union {\n        __long  __l;                    // 24     bytes\n        __short __s;                    // 24     bytes\n    } __r_;                             // 24     bytes\n}\n\n```\n\nIn short string mode, the first byte of the string stores the size (which is less than 24). The rest bytes store the string locally. The variable `__lx` is used for alignment with `wchar_t`.\n\nIn order to distinguish a long string from a short one, the first byte of a long string (also the first byte of its capacity) is set to a mask 0x80 (which is larger than the maximum length of short string). This mask actually half the maximum capacity of the long string, but 0x 7fff ffff ffff ffff is huge enough comparing to achievable memory size.\n\nThis design eliminates the size of a string to 24 bytes, and provides a longer local string (15 -> 22 for `char`, or 7 -> 10 for `wchar_t`).\n\n","htmlEncrypted":"","nonce":"","timeToRead":null,"title":"C++ Small String Optimization","date":"1601769600000","tags":["cpp"],"path":"posts/cpp-sso","excerpt":"In this post, SSO (small string optimization) in C++ is studied and some more efforts for small static strings are made.","links":[],"commit":0,"type":"posts"}},"internal":{"contentFilePath":"/home/runner/work/tc-imba.github.io/tc-imba.github.io/content/posts/2020-10-04-cpp-sso/index.md"}}},"pageContext":{"contentFilePath":"/home/runner/work/tc-imba.github.io/tc-imba.github.io/content/posts/2020-10-04-cpp-sso/index.md","postPath":"posts/cpp-sso","translations":[{"hreflang":"en","path":"/posts/cpp-sso"}],"frontmatter":{"title":"C++ Small String Optimization","tags":["cpp"],"date":"2020-10-04T00:00:00.000Z","path":"posts/cpp-sso","excerpt":"In this post, SSO (small string optimization) in C++ is studied and some more efforts for small static strings are made."}}},"staticQueryHashes":["1552981879","2158328490","3013679938"],"slicesMap":{}}