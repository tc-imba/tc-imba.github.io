{"version":3,"file":"440-f9698761717831adc18d.js","mappings":"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","sources":["webpack://tc-imba.github.io/./node_modules/lodash/debounce.js","webpack://tc-imba.github.io/./node_modules/lodash/now.js","webpack://tc-imba.github.io/./node_modules/rsuite/esm/utils/useMount.js","webpack://tc-imba.github.io/./node_modules/rsuite/esm/utils/useEventListener.js","webpack://tc-imba.github.io/./node_modules/rsuite/esm/Affix/Affix.js","webpack://tc-imba.github.io/./node_modules/rsuite/esm/utils/useElementResize.js","webpack://tc-imba.github.io/./node_modules/rsuite/esm/Affix/index.js"],"sourcesContent":["var isObject = require('./isObject'),\n    now = require('./now'),\n    toNumber = require('./toNumber');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n","var root = require('./_root');\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n","'use client';\nimport { useEffect, useRef } from 'react';\nvar useMount = function useMount(callback) {\n  var mountRef = useRef(callback);\n  mountRef.current = callback;\n  useEffect(function () {\n    var _mountRef$current;\n    (_mountRef$current = mountRef.current) === null || _mountRef$current === void 0 ? void 0 : _mountRef$current.call(mountRef);\n  }, []);\n};\nexport default useMount;","'use client';\nimport { useEffect } from 'react';\nimport on from 'dom-lib/on';\n\n/**\n * Attach the event handler directly to the specified DOM element.\n *\n * @param element The target to listen for events on\n * @param event The DOM event name\n * @param handler An event handler\n * @param capture Whether or not to listen during the capture event phase\n */\nexport default function useEventListener(eventTarget, event, listener, capture) {\n  if (capture === void 0) {\n    capture = false;\n  }\n  useEffect(function () {\n    var target = typeof eventTarget === 'function' ? eventTarget() : eventTarget;\n    var controller = target ? on(target, event, listener, capture) : null;\n    return function () {\n      controller === null || controller === void 0 ? void 0 : controller.off();\n    };\n  }, [eventTarget, event, listener, capture]);\n}","'use client';\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport React, { useCallback, useEffect, useRef, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport debounce from 'lodash/debounce';\nimport getOffset from 'dom-lib/getOffset';\nimport { mergeRefs, useClassNames, useElementResize, useEventListener, useMount } from '../utils';\n/**\n * Get the layout size and offset of the mount element\n */\nfunction useOffset(mountRef, onOffsetChange) {\n  var _useState = useState(null),\n    offset = _useState[0],\n    setOffset = _useState[1];\n  var updateOffset = useCallback(function () {\n    if (!mountRef.current) {\n      return;\n    }\n    var newOffset = getOffset(mountRef.current);\n    if ((newOffset === null || newOffset === void 0 ? void 0 : newOffset.height) !== (offset === null || offset === void 0 ? void 0 : offset.height) || (newOffset === null || newOffset === void 0 ? void 0 : newOffset.width) !== (offset === null || offset === void 0 ? void 0 : offset.width) || (newOffset === null || newOffset === void 0 ? void 0 : newOffset.top) !== (offset === null || offset === void 0 ? void 0 : offset.top) || (newOffset === null || newOffset === void 0 ? void 0 : newOffset.left) !== (offset === null || offset === void 0 ? void 0 : offset.left)) {\n      setOffset(newOffset);\n      if (offset !== null && newOffset !== null) {\n        onOffsetChange === null || onOffsetChange === void 0 ? void 0 : onOffsetChange(newOffset);\n      }\n    }\n  }, [mountRef, offset, onOffsetChange]);\n\n  // Update after the element size changes\n  useElementResize(function () {\n    return mountRef.current;\n  }, updateOffset);\n\n  // Initialize after the first render\n  useMount(updateOffset);\n\n  // Update after window size changes\n  useEventListener(window, 'resize', updateOffset, false);\n\n  // Update after window scroll\n  useEventListener(window, 'scroll', debounce(updateOffset, 100), false);\n  return offset;\n}\n\n/**\n * Get the layout size and offset of the container element\n * @param container\n */\nfunction useContainerOffset(container) {\n  var _useState2 = useState(null),\n    offset = _useState2[0],\n    setOffset = _useState2[1];\n  useEffect(function () {\n    var node = typeof container === 'function' ? container() : container;\n    setOffset(node ? getOffset(node) : null);\n  }, [container]);\n  return offset;\n}\n\n/**\n * Check whether the current element should be in a fixed state.\n * @param offset\n * @param containerOffset\n * @param props\n */\nfunction useFixed(offset, containerOffset, props) {\n  var top = props.top,\n    onChange = props.onChange;\n  var _useState3 = useState(false),\n    fixed = _useState3[0],\n    setFixed = _useState3[1];\n  var handleScroll = useCallback(function () {\n    if (!offset) {\n      return;\n    }\n    var scrollY = window.scrollY || window.pageYOffset;\n\n    // When the scroll distance exceeds the element's top value, it is fixed.\n    var nextFixed = scrollY - (Number(offset === null || offset === void 0 ? void 0 : offset.top) - Number(top)) >= 0;\n\n    // If the current element is specified in the container,\n    // add to determine whether the current container is in the window range.\n    if (containerOffset) {\n      nextFixed = nextFixed && scrollY < Number(containerOffset.top) + Number(containerOffset.height);\n    }\n    if (nextFixed !== fixed) {\n      setFixed(nextFixed);\n      onChange === null || onChange === void 0 ? void 0 : onChange(nextFixed);\n    }\n  }, [offset, top, containerOffset, fixed, onChange]);\n\n  // Add scroll event to window\n  useEventListener(window, 'scroll', handleScroll, false);\n  return fixed;\n}\nvar Affix = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  var _merge;\n  var _props$as = props.as,\n    Component = _props$as === void 0 ? 'div' : _props$as,\n    _props$classPrefix = props.classPrefix,\n    classPrefix = _props$classPrefix === void 0 ? 'affix' : _props$classPrefix,\n    className = props.className,\n    children = props.children,\n    container = props.container,\n    _props$top = props.top,\n    top = _props$top === void 0 ? 0 : _props$top,\n    onChange = props.onChange,\n    onOffsetChange = props.onOffsetChange,\n    rest = _objectWithoutPropertiesLoose(props, [\"as\", \"classPrefix\", \"className\", \"children\", \"container\", \"top\", \"onChange\", \"onOffsetChange\"]);\n  var mountRef = useRef(null);\n  var offset = useOffset(mountRef, onOffsetChange);\n  var containerOffset = useContainerOffset(container);\n  var fixed = useFixed(offset, containerOffset, {\n    top: top,\n    onChange: onChange\n  });\n  var _useClassNames = useClassNames(classPrefix),\n    withClassPrefix = _useClassNames.withClassPrefix,\n    merge = _useClassNames.merge;\n  var classes = merge(className, (_merge = {}, _merge[withClassPrefix()] = fixed, _merge));\n  var _ref = offset || {},\n    width = _ref.width,\n    height = _ref.height;\n  var placeholderStyles = fixed ? {\n    width: width,\n    height: height\n  } : undefined;\n  var fixedStyles = {\n    position: 'fixed',\n    top: top,\n    width: width,\n    zIndex: 10\n  };\n  var affixStyles = fixed ? fixedStyles : undefined;\n  return /*#__PURE__*/React.createElement(Component, _extends({}, rest, {\n    ref: mergeRefs(mountRef, ref)\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    className: classes,\n    style: affixStyles\n  }, children), fixed && /*#__PURE__*/React.createElement(\"div\", {\n    \"aria-hidden\": true,\n    style: placeholderStyles\n  }));\n});\nAffix.displayName = 'Affix';\nAffix.propTypes = {\n  top: PropTypes.number,\n  onChange: PropTypes.func,\n  container: PropTypes.oneOfType([PropTypes.any, PropTypes.func])\n};\nexport default Affix;","'use client';\nimport { useEffect, useRef } from 'react';\nimport { ResizeObserver } from '@juggle/resize-observer';\n\n/**\n * Attach the event handler directly to the specified DOM element,\n * and it will be triggered when the size of the DOM element is changed.\n *\n * @param eventTarget The target to listen for events on\n * @param listener An event handler\n */\nexport default function useElementResize(eventTarget, listener) {\n  var resizeObserver = useRef();\n  useEffect(function () {\n    if (!resizeObserver.current) {\n      var target = typeof eventTarget === 'function' ? eventTarget() : eventTarget;\n      if (target) {\n        resizeObserver.current = new ResizeObserver(listener);\n        resizeObserver.current.observe(target);\n      }\n    }\n    return function () {\n      var _resizeObserver$curre;\n      (_resizeObserver$curre = resizeObserver.current) === null || _resizeObserver$curre === void 0 ? void 0 : _resizeObserver$curre.disconnect();\n    };\n  }, [eventTarget, listener]);\n}","'use client';\nimport Affix from './Affix';\nexport default Affix;"],"names":["isObject","now","toNumber","nativeMax","Math","max","nativeMin","min","module","exports","func","wait","options","lastArgs","lastThis","maxWait","result","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","TypeError","invokeFunc","time","args","thisArg","undefined","apply","shouldInvoke","timeSinceLastCall","timerExpired","trailingEdge","setTimeout","timeWaiting","remainingWait","debounced","isInvoking","arguments","this","leadingEdge","clearTimeout","cancel","flush","root","Date","callback","mountRef","useRef","current","useEffect","_mountRef$current","call","useEventListener","eventTarget","event","listener","capture","target","controller","on","off","useOffset","onOffsetChange","resizeObserver","_useState","useState","offset","setOffset","updateOffset","useCallback","newOffset","getOffset","height","width","top","left","observe","_resizeObserver$curre","disconnect","window","Affix","props","ref","_merge","_props$as","as","Component","_props$classPrefix","classPrefix","className","children","container","_props$top","onChange","rest","containerOffset","_useState2","node","useContainerOffset","fixed","_useState3","setFixed","handleScroll","scrollY","pageYOffset","nextFixed","Number","useFixed","_useClassNames","useClassNames","withClassPrefix","classes","merge","_ref","placeholderStyles","affixStyles","position","zIndex","mergeRefs","style","displayName","propTypes"],"sourceRoot":""}